# Subset OA data and calculate percentages using demominators 
count_to_percentage <- function(input_df, variable_choices) {
  tibble::as.tibble(input_df[variable_choices$VariableCode] / 
                      input_df[variable_choices$StatisticalUnit] * 100)
}

ihs <- function(input_df) {
  as.tibble(log(input_df + sqrt(input_df ^ 2 + 1)))
}

z_scores <- function(input_df) {
  # Compute the column-wise means for all observations
  mean_by_col <- apply(input_df, 2, mean)
  # Compute the column-wise sample sd's for *all* observations
  sd_by_col <- apply(input_df, 2, sd)
  # Create the z-scores via the 'scale' function
  zscores <-scale(input_df, center = mean_by_col, scale = sd_by_col)
  as.tibble(zscores)
}

# Corrolation
cor_cutoff <- function(variable, cutoff) {
  cor_mat[,variable][cor_mat[,variable] >= cutoff | cor_mat[,variable] <= -cutoff]
}

# Wrapper for kmeans
k_means <- function(k, input_data, n_start_input) {
  set.seed(2494)
  kmeans(input_data, 
         k, iter.max = 1000, 
         nstart = n_start_input, 
         algorithm = "Lloyd")}

k_comparison <- function(input_data, iter=1:15, n_start=25) {
  # Set up parrallel processing for windows
  cl <- makeCluster(detectCores() - 1)
  clusterExport(cl=cl,
                varlist=c("iter", "k_means", "input_data", "n_start"),
                envir=environment())
  system.time(
    k_choice_clust_list <- parLapply(cl, iter, k_means, input_data, n_start)
  )
  stopCluster(cl)
  return(k_choice_clust_list)
}

# Scree plot
scree <- function(k_choice_clust_list, iter, title) {
  wss <- purrr::map(k_choice_clust_list, ~.$tot.withinss)
  plot(iter, wss, 
       type = "o", 
       main = paste("Cluster Scree Plot: ", title),
       xlab = "Number of Clusters", 
       ylab = "Within Cluster Sum of Squares")
  dev.copy(pdf, paste("figures\\", title , "_scree.pdf"))
  dev.off()
  
  
  min_clus <-purrr::map(k_choice_clust_list, ~min(.$size))
  plot(iter, min_clus, 
       type = "h", 
       main = paste("Smallest Cluster Plot:", title),
       xlab = "Number of Clusters", 
       ylab = "Smallest Cluster Size")
  dev.copy(pdf, paste("figures\\", title , "_smallest_cluster.pdf"))
  dev.off()
}

run_kmeans_comp_subgroup <- function(subgroup, data, num_pc) {
  data %>%
    filter(cluster==subgroup) %>% 
    select(1:num_pc) %>% 
    k_comparison(iter) %>% 
    scree(iter, paste("subgroup ", subgroup))
}

run_kmeans_subgroup <- function(subgroup, k, nstart) {
  subgroup <- subgroup[1:ncol(subgroup)-1]
  k_means(k, subgroup, nstart)
}

avg_z <- function(cluster_choice, sub_kmeans_obj, k_means_obj, cv_ihs_z) {
  a <- as_tibble(cbind(cv_ihs_z, cluster=k_means_obj$cluster))
  a <- filter(a, cluster==cluster_choice)[, -length(a)]
  ddply(a, .(sub_kmeans_obj[[cluster_choice]]$cluster), numcolwise(mean))[, -1]
}

cluster_difference <- function(sub_cluster_zscores, cluster_zscores) {
  cluster_zscores <- unlist(cluster_zscores)
  sub_cluster_zscores - cluster_zscores[col(sub_cluster_zscores)] # -
}

rename_rows <- function(df, name) {
  row.names(df) <- map(1:nrow(df), function(row, name) paste(name, ": Subgroup ", row, sep=""), name)
  return(df)
}

create_heatmap <- function(mean_cluster_zscores, num_clusters, margins) {
  # Create heatmap
  colours <- rev(brewer.pal(10,'BrBG')) # reverse colours
  break_nums <- c(-1e10,-2,-1.5,-1,-0.5,0,0.5,1,1.5,2,+1e10) #3
  legend_names <- c("<-2","-2 to -1.5","-1.5 to -1","-1 to -0.5","-0.5 to 0","0 to 0.5","1 to 2","1.5 to 2","2 to 2.5",">2")
  out <- heatmap(t(mean_cluster_zscores),
          distfun = function(x) dist(x, method = "euc"),
          hclustfun = function(x) hclust(x, method = "average"),
          scale = 'none',
          col = colours,
          breaks = break_nums, #3
          cexRow = .5, #.5
          cexCol = .8,
          mar=margins,
          #Colv = NA,
          Rowv = NA,
          keep.dendro=TRUE,
          add.expr= abline(h = (0:length(mean_cluster_zscores)) + 0.5, v = (0:num_clusters) + 0.5, col = 'white'))
  par(xpd=TRUE) 
  #legend(title=expression(bold("z-score\n\n")), 0.12, -0.07, legend_names, title.adj=0.48, lty = 1, lwd = 20, col=colours, cex=0.7, bty = "n", horiz=TRUE, adj=c(0.5, -2), x.intersp=-1)
  legend(title=expression(bold("z-score\n\n")), 0.10, -0.03, legend_names, title.adj=0.48, lty = 1, lwd = 20, col=colours, cex=0.7, bty = "n", horiz=TRUE, adj=c(0.5, -2), x.intersp=-1)
  par(xpd=FALSE)
  return(out)
 }

# produce radial plots
radial_plot <- function(data, main_title, min_max=c(-2,3), legend_names) {
  print(main_title)
  par(cex.axis=.7)
  par(cex.lab=.6)
  colours <- brewer.pal(8,'Set1')
  #pdf(paste("subgroups\\", main_title, ".pdf", sep=""), paper="a4")
  p <- radial.plot(data, labels=names(data),
              start=5,
              clockwise=TRUE,
              rp.type=c("p"),
              line.col=colours,
              lwd=1,
              #lty = 2,
              #show.centroid=TRUE,
              point.col="black", 
              label.prop=0.91,
              radlab=TRUE,
              radial.lim = min_max,
              #grid.bg = grid_cols,
              grid.col = "#E0E0E0",
              col.sub = "green",
              mar=c(2, 0, 5, 0),
              show.radial.grid=TRUE
              #poly.col = colours
              #rad.col = c("red", "blue")
  )
  title(paste(main_title, "\n\n"))
  par(xpd=TRUE) 
  legend(9.5,-10,legend_names,lty=1,lwd=1,col=colours, cex=0.7, bty = "n")
  #legend(9.5,-9,legend_names,lty=1,lwd=1,col=colours, cex=0.7, bty = "n")
  par(xpd=FALSE) 
  dev.copy(pdf, paste("figures\\read\\subgroups\\", main_title, ".pdf", sep=""))
  dev.off()
}

cluster_tibble <- function(subgroup, kmeans_obj, cluster_name) {
  tib <- tibble(subgroup$OA, kmeans_obj$cluster)
  names(tib) <- c("OA_SA", cluster_name) 
  return(tib)
}

euc_dist = function(x1, x2) {
  temp = x1-x2
  sum(temp*temp)
}

find_distances <- function(input_data, kmeans_obj) {
  input_data <- as.data.frame(input_data)
  pb <- txtProgressBar(min = 0, max = nrow(input_data), style = 3)
  run_and_update <- function(row) {
    setTxtProgressBar(pb, row)
    map_dbl(1:nrow(kmeans_obj$centers), 
            function(cluster) sqrt(sum(map_dbl(1:ncol(input_data), 
                                               function(col) euc_dist(input_data[row, col], kmeans_obj$centers[cluster, col])))))
  }
  dist_list <- map(1:nrow(input_data), run_and_update)
  distances <- as_tibble(matrix(unlist(dist_list), ncol=nrow(kmeans_obj$centers), byrow=TRUE))
  names(distances) <- paste("Cluster", 1:nrow(kmeans_obj$centers), "_SED", sep="")
  cv_distances <- tibble::add_column(distances, "Cluster"=k_means_obj$cluster)
  return(distances)
}

dist_matrix <- function(distances, cluster_num, avg) {
  cluster_dists <- purrr::map(1:cluster_num, 
                              function(cluster_y) purrr::map_dbl(1:cluster_num, 
                                                                 function(cluster_x) avg(unlist(filter(
                                                                   distances, distances["Cluster"] == cluster_x)[cluster_y]))))
  names(cluster_dists) <- paste("center", 1:cluster_num)
  distances <- as.data.frame(cluster_dists)
  row.names(distances) <- paste("cluster", (1:cluster_num))
  return(t(distances))  
}

dist_count <- function(dist_mat, num_clusters) {
  purrr:::map_int(1:num_clusters, 
                  function(x, dist_mat) sum(dist_mat[x] < dist_mat[x, x]),
                  dist_mat)
}

percent_nearest <- function(distances, levels) {
  membership <- t(apply(select(distances, -ncol(distances)), 1, function(x) x / sum(x) * 100))
  nearest <- apply(membership, 1, function(x) sort(x, FALSE)[2] - min(x))
  percent_nearest <- map_dbl(levels, function(x) sum(nearest > x) / length(nearest) * 100)
  return(percent_nearest)
}